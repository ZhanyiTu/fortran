!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!  This is a single-file code that will solve the 2D heat equation
!     u_t = A * u_xx + B * u_yy
!  with grid and simulation parameters and heat diffusivity coefficients A & B
!  given in the input file NAMELIST. Additionally, the initial condition can
!  be set by changing the INITIAL_CONDITION function found after the
!  INITIALIZE_GRID subroutine.
!
!  To compile this code, run the command:
!
!     gfortran main.f90 -o serial_heat_equation_solver.exe
!
!  To run the executable (the .exe file generated by compiling), run the
!  command:
!
!     ./serial_heat_equation_solver
!
!  The code will write the grid to a file in the output_data subdirectory, and
!  the file name will give the time step that grid corresponds to.
!
!  Variables:
!    - start_time, end_time : Beginning, end time of simulation.
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

PROGRAM SERIAL_HEAT_EQN_SOLVER

IMPLICIT NONE

! Real precision types, a la Metcal et. al (2004, p. 71).
INTEGER, PARAMETER :: sp = SELECTED_REAL_KIND(6, 37)
INTEGER, PARAMETER :: dp = SELECTED_REAL_KIND(15, 307)
INTEGER, PARAMETER :: qp = SELECTED_REAL_KIND(33, 4931)

REAL(dp) :: start_time, end_time

CALL CPU_TIME(start_time)
CALL MAIN
CALL CPU_TIME(end_time)

WRITE(*,"(A,F10.5,A)") "Execution time: ", end_time - start_time, "."
WRITE(*,"(A)") "Simulation complete. Normal termination..."


CONTAINS

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SUBROUTINE MAIN
! This is the main program driver. It calls subroutines which initialize the
! simulation parameters (reads the NAMELIST file), initialize the grid
! (allocate the appropriate amount of memory to the grid and sets its initial
! condition), and steps the simulation forward in time.
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

IMPLICIT NONE

INTEGER :: x_len, y_len, output_freq
REAL(dp) :: x_ref, y_ref, dx, dy, dt, init_time, fin_time, &
  & x_diffus, y_diffus
REAL(dp), ALLOCATABLE :: temperature_grid(:,:,:)

CALL INITIALIZE_PARAMETERS(x_len, y_len, dx, dy, dt, x_diffus, y_diffus, &
&  x_ref, y_ref, init_time, fin_time, output_freq)

CALL INITIALIZE_GRID(x_len, y_len, dx, dy, x_ref, y_ref, temperature_grid)

CALL TIME_STEP(x_len, y_len, dx, dy, dt, x_diffus, y_diffus, init_time, &
&  fin_time, output_freq, temperature_grid)

RETURN

END SUBROUTINE MAIN

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SUBROUTINE INITIALIZE_PARAMETERS(x_len, y_len, dx, dy, dt, x_diffus, &
&  y_diffus, x_ref, y_ref, init_time, fin_time, output_freq)
! Reads the NAMELIST containing the parameters for the simulation.
!
! Variables:
!   - x_len, y_len : Number of x-, y-grid points.
!   - dx, dy : x-, y- grid spacing.
!   - dt : Time step size.
!   - x_diffus, y_diffus : Thermal diffusivity in x-, y-directions.
!   - x_ref, y_ref : Position of reference grid point (bottom-left).
!   - init_time, fin_time : Initial and final time of simulation.
!   - output_freq : Output frequency of the simulation.
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

IMPLICIT NONE

INTEGER :: x_len, y_len, output_freq
REAL(dp) :: x_ref, y_ref, dx, dy, dt, init_time, fin_time, &
  & x_diffus, y_diffus

NAMELIST /model/ x_len, y_len, dx, dy, dt, x_diffus, y_diffus, &
  & x_ref, y_ref, init_time, fin_time, output_freq

OPEN(1000, file = "NAMELIST")
READ(1000, nml = model)
CLOSE(1000)

END SUBROUTINE INITIALIZE_PARAMETERS

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SUBROUTINE INITIALIZE_GRID(x_len, y_len, dx, dy, x_ref, y_ref, &
&  temperature_grid)
! Allocates the appropriate amount of memory to the grid and sets the initial
! condition. The INITIAL_CONDITION function is defined below, and is dependent
! only on x and y.
!
! Note, the grid is size (x_len, y_len, 2), with the last index being the
! for time steps. The initial condition is set on (:,:,1). To obtain the first
! time step, the TIME_STEPPER subroutine uses the values from (;,:,1) and
! stores them in (:,:,2). To obtain the fsecond time step, the TIME_STEPPER
! subroutine uses the values from (;,:,2) and stores them in (:,:,1). This
! alternating continues until the simulation is complete.
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

IMPLICIT NONE

INTEGER :: x_len, y_len, output_freq
REAL(dp) :: x_ref, y_ref, dx, dy, dt, init_time, fin_time, &
  & x_diffus, y_diffus
REAL(dp), ALLOCATABLE :: temperature_grid(:,:,:)
INTEGER :: i, j

! Have temperature grid contain two time steps (last index).
ALLOCATE(temperature_grid(x_len, y_len, 2))
temperature_grid(:,:,1) = 0.0_dp

! Fill in the initial condition for the temperature grid.
DO j = 1, y_len
  DO i = 1, x_len
    temperature_grid(i, j, 1) = &
      & INITIAL_CONDITION(x_ref + i * dx, y_ref + j * dy)
  END DO
END DO

! Zeros out boundary.
! Faster to assign value to array which is contiguous in memory all at once.
temperature_grid(:, 1, 1) = 0.0
temperature_grid(:, y_len, 1) = 0.0
! Faster to assign value to array which is not contiguous in memory with DO.
DO j = 1, y_len
  temperature_grid(1, j, 1) = 0.0
  temperature_grid(x_len, j, 1) = 0.0
END DO

temperature_grid(:,:,2) = temperature_grid(:,:,1)

END SUBROUTINE INITIALIZE_GRID

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
REAL(dp) FUNCTION INITIAL_CONDITION(x_pos, y_pos) RESULT(output)
!  Function to set the initial condition of the grid, based on x and y.
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

IMPLICIT NONE

REAL(dp), INTENT(in) :: x_pos, y_pos

! f(x, y) = x + 2 * y.
output = x_pos + 2 * y_pos

END FUNCTION INITIAL_CONDITION

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SUBROUTINE TIME_STEP(x_len, y_len, dx, dy, dt, x_diffus, y_diffus, &
&  init_time, fin_time, output_freq, temperature_grid)
! The main driver for the model's time integration. It calls the subroutine
! TIME_STEP_SCHEME, which updates variables, and calls the subroutine
! WRITE_OUTPUT which writes the current time step to file.
!
! Variables:
!   - step : Step in simulation.
!   - max_step : Steps required to finish simulation.
!   - time : Curent time of simulation.
!   - stability_constraint : Stability condition for scheme.
!   - step_parity : Fill in (:,:,1) or (:,:,2) of temperature_grid.
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

IMPLICIT NONE

INTEGER :: x_len, y_len, output_freq
REAL(dp) :: x_ref, y_ref, dx, dy, dt, init_time, fin_time, &
  & x_diffus, y_diffus
REAL(dp) :: temperature_grid(:,:,:)
INTEGER :: step, max_step, step_parity
REAL(dp) :: time, stability_constraint

! Stability constraint derived from our time step method, which is Forward
! Euler in time, and a 1st order centered difference for each spatial
! derivative (using Von Neumann analysis).
stability_constraint = 1.0_dp/(2.0_dp * (x_diffus/(dx**2) + y_diffus/(dy**2)))

IF ((dt .GT. stability_constraint)) THEN
  WRITE(*,"(A,A)") "WARNING: Time step is too large numerical ", &
  & "scheme is unstable."
END IF

step_parity = 1
step = 0
time = init_time
max_step = (fin_time - init_time)/dt

IF (max_step .LT. output_freq) THEN
  ERROR STOP "Output frequency too large. Please reduce."
END IF

! Output the initial condition.
CALL WRITE_OUTPUT(x_len, y_len, temperature_grid, step, step_parity)

! Step simulation forward in time.
DO WHILE (time .LE. fin_time)
  step_parity = 3 - step_parity
  CALL TIME_STEP_SCHEME(x_len, y_len, dx, dy, dt, x_diffus, y_diffus, &
  &  init_time, fin_time, temperature_grid, step_parity)
  time = time + dt
  step = step + 1

  ! Write output at desired frequency.
  IF (MOD(step, output_freq) .EQ. 0) THEN
    CALL WRITE_OUTPUT(x_len, y_len, temperature_grid, step, step_parity)
  END IF
END DO

END SUBROUTINE TIME_STEP

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SUBROUTINE TIME_STEP_SCHEME(x_len, y_len, dx, dy, dt, x_diffus, y_diffus, &
&  init_time, fin_time, temperature_grid, time_index)
! The numerical scheme for the time step, using a Forward Euler scheme in time
! and a first-order center difference in space.
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

IMPLICIT NONE

INTEGER :: x_len, y_len, output_freq
REAL(dp) :: x_ref, y_ref, dx, dy, dt, init_time, fin_time, &
  & x_diffus, y_diffus
REAL(dp) :: temperature_grid(:,:,:)
INTEGER :: time_index, prev_time_index

prev_time_index = 3 - time_index

temperature_grid(2:x_len-1, 2:y_len-1, time_index) = &
&  temperature_grid(2:x_len-1, 2:y_len-1, prev_time_index) &
&  + (dt * x_diffus / (dx**2)) &
&  * (temperature_grid(3:x_len, 2:y_len-1, prev_time_index) &
&     - 2 * temperature_grid(2:x_len-1, 2:y_len-1, prev_time_index) &
&     + temperature_grid(1:x_len-2, 2:y_len-1, prev_time_index)) &
&  + (dt * y_diffus / (dy**2)) &
&  * (temperature_grid(2:x_len-1, 3:y_len, prev_time_index) &
&     - 2 * temperature_grid(2:x_len-1, 2:y_len-1, prev_time_index) &
&     + temperature_grid(2:x_len-1, 1:y_len, prev_time_index))

END SUBROUTINE TIME_STEP_SCHEME

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SUBROUTINE WRITE_OUTPUT(x_len, y_len, temperature_grid, step, time_index)
!  Writes the given array to a .dat file
!
!  Variables:
!    - step : Step in simulation.
!    - time_index : Use in (:,:,1) or (:,:,2) of temperature_grid.
!    - i, j : x-, y-grid point index.
!    - fname : File name.
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

IMPLICIT NONE

INTEGER :: x_len, y_len
REAL(dp) :: temperature_grid(:,:,:)
INTEGER :: step, time_index, i, j, proc_id
CHARACTER*30 :: fname

WRITE(fname,"(A,I0.8,A,I0.4,A)") "./output_data/out_", step, ".dat"

OPEN(100, file = fname, form = "formatted")

DO j = 1 , y_len
  DO i = 1, x_len
    WRITE(100, "(E32.16, 1x)",  ADVANCE = "NO") &
    &  temperature_grid(i, j, time_index)
  END DO
  WRITE(100, "(1x)")
END DO
CLOSE(100)

WRITE(*,"(A, A, A)") "Wrote grid to ", fname, "."

END SUBROUTINE WRITE_OUTPUT

END PROGRAM
